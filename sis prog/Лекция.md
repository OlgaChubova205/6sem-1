LK1</br>
---
История операционных систем</br>
---
ЭВМ 1го поколения - ОС пока не существует</br>
1943 год - устройства для расчета баллистической таблицы</br>
ЭНИАК - первый электронный дифференциальный анализатор(цифровой вычислитель)</br>

Особенности:
1. использавание ламп(греются и горят)
2. возможность перепрограммирования
3. используются перфокарта

Недостатки:
1. для решения диф. уравнений ~ 1 млн перфокарт(перепрограммирование 2+ дня)

---
Архитектура фон Неймана
---
Особенности: 
1. переход на двоичную систему (есть сигнал - 1; нет сигнала - 0)
2. уходят от перфокарт, память состоит из пронумерованных ячеек

Программа - последовательность команд, выполняются одна за другой.</br>
![image](https://user-images.githubusercontent.com/97594290/213094682-90d537a3-b02c-47cd-950a-00b22ba40ca6.png)</br>

---
ЭВМ 2го поколения
---

Плюсы: 
1. нет тепла, нет перегорания -> надёжно
2. маленький размер, плотная компановка -> ЭВМ меньше

Недостатки:
1. сложная диагностика
2. дорогое производство

Появление алгоритмических языков (COBOL, ALGOL)</br>
Появление компиляторов -> появление программистов</br>
Пакетная обработка данных - задачи сменяются не вручную, а подаются на вход пачкой</br>

---
ЭВМ 3-4го поколения
---
3е - Интегральные схемы (1 млн операций)</br>
4е - Большие интегральные схемы (10 млн операций)</br>
Плюсы интегральных схем:
1. автоматизация производства -> уменьшение стоимости

Особенности:
1. Многозадачность, принцип мультипрограммирования, разделение времени
2. Появление виртуальной памяти(запуск части программы для выполнения)
3. База данных

Вместо перфокарт магнитные ленты и магнитные диски</br>
Появляются Apple и Unix</br>
32-разрядное ОС


Unix
---
Самописная файловая система, командная оболочка, утилиты

Linux
---
80-е годы - появление протоколов TCP/IP(транспортный сетевой протокол, протокол передачи данных) - этот протокол определил что информация хванится в сети, имеет уникальный номер(IP), что позволяет отслеживать передачу</br>
linux(Линус Торвальдс) - 1991 год</br>
1. Утилиты gcc, bash
2. Появление системы вызова UNIX
3. монолитное ядро

---
Функции операцинной системы
---
1. Обеспечение выполнение программ
2. Обеспечение безопасности
3. Огранизация сетевого стека
4. Файловые системы
5. Доступ к устройствам ввода-вывода

![image](https://user-images.githubusercontent.com/97594290/213100967-bf066bef-c063-4704-bfd2-8b313ffd5b6b.png)
![image](https://user-images.githubusercontent.com/97594290/213101273-91a34d51-f0b5-4173-b116-f254f8c0e2e1.png)</br>
Микроядеркая архитектура - Windows</br>
Совсестимости ОС: двоичная(запуск exe-файла), на уровне исзодныз кодов(передается приложение с кодом)</br>
![image](https://user-images.githubusercontent.com/97594290/213102130-1b30165a-6013-4fb0-ab81-b962c80b99f6.png)</br>
В Unix всё есть файл(флешка, клавиатура, word)

Типы файлов:
1. символьные устройства(клавиатура)
2. блочные устройства(флешка)
3. каталоги(папка)
4. ссылки(ярлык)
5. именованные каналы
6. сокеты



STDIN(0) - Стандартный ввод. Файл, из которого осуществляется чтение 
STDOUT - Стандартный вывод. Файл, в который осуществляется запись 
STDERR(2) - Стандартный поток ошибок


#Перенаправление ввода 
command < filename
Перенапраление вывода 
command>filename - rewrite
command 1 > fulename 
command >>filename - append 
2 >/dev/null - убирает поток ошибок 

# Процессы и потоки 

Процесс - набор ресурсов :
память
открытие файловых дескриторов
контекст выполнения 
pid - уникальный индентификатор 
обработчики сигналов
Код выхода 
Рабочий каталог
Переменные окружения 
Состояния процесса

Потоки имеют: общую виртуальную память, каждый - свой виртуальный процессор

![image](https://user-images.githubusercontent.com/97594420/217463252-94eb6199-11c0-46b4-a12b-f4f13e93fb8b.png)


# Вирутуальная файловая система 

![image](https://user-images.githubusercontent.com/97594420/217465950-0173e940-99f3-4259-85b9-b01f8e2cda73.png)

![image](https://user-images.githubusercontent.com/97594420/217466129-82ca0b1a-0807-4263-8e58-3460cfa49373.png)


# Появление процесса в системе
init - создание процесса
fork - копирование процесса
fork - дочерний и родительский процесс
Дочерний процесс - полная копия родительского, но получает управление первым 
А его PID присваивается родительскому процессу
Адресное пространство родителя - совместное
![image](https://user-images.githubusercontent.com/97594420/217467549-49c14dfa-3b92-4cb9-a0d1-da4016c7e4ea.png)
Смерть процесса = команда kill
Если родительский процесс завершился раньше дочернего, то у ребенка будет другой родитель










